---
layout: frontpage
title: Failure
use_math: true
category: chapter
---

$$
\newcommand\calc{\mathsf{calc}\;}
\newcommand\parse{\mathsf{parse}\;}
\newcommand\typeof{\mathsf{typeof}\;}
\newcommand\interp{\mathsf{interp}\;}
\newcommand\eval{\mathsf{eval}\;}
\newcommand\NUM{\mathsf{NUM}\;}
\newcommand\iif{\mathsf{if}\;}
\newcommand\tthen{\;\mathsf{then}\;}
\newcommand\eelse{\;\mathsf{else}\;}
\newcommand\iisZero{\mathsf{isZero}\;}
\newcommand\aand{\;\mathsf{\&\&}\;}
\newcommand\lleq{\;\mathtt{<=}\;}
\newcommand\ttrue{\;\mathsf{true}}
\newcommand\ffalse{\;\mathsf{false}}
$$

# Failure Is an Option

We've established that `ABE` fails for test cases that attempt to use Boolean values where numbers should be used or numbers where Boolean values should be used.  Before addressing that specific problem, let's look at how failure should be handled generally.

First a bit of new terminology.  We are defining a new language called `ABE` using Haskell to build parsers and interpreters.  We will refer to `ABE` as the *external language* or *domain specific language*.  We refer to Haskell as the *host language* or *implementation language*.  The distinction is we are building tools for `ABE` and using Haskell to build them.

When the current `ABE` interpreter fails, it fails in the host language.  When we call the Haskell `error` function we jump out of our interpreter and generate a Haskell error message.  This approach works, but has several problems.

First, we have no control over errors.  The happen and our control of execution ends.  Java uses an innovative approach where exceptions are Java data structures that allow us to write Java programs to process them.  This is how systems like Eclipse can allow new tools that generate error messages to simply be plugged into the infrastructure.  Right now, we can't do this.

Second, our only choice is to fail.  What if our interpreters can avoid failures?  What if we can predict failures during or before execution?  This results in systems that are more robust and code that we can better control.

Let's look at two approaches to handling errors.  The first will handle them *dynamically* or at run-time.  Our interpreter will generate error messages as data structures that we can process how we choose.  The second will handle them *statically* by predicting runtime failure before execution.

## Runtime Error Checking

We will update our `ABE` evaluator to catch errors and run time rather than falling into Haskell using the `error` function.  The new evaluator will return either a value or an error message that we can handle however we want.

### Eval

Let's change the type signature of the `ABE` `eval` function just a bit and define a new function called `evalErr` that returns either a n `ABE` term or a string representing an error:

{% highlight haskell %}
evalErr :: ABE -> Either ABE String
{% endhighlight %}

If you're not familiar with the `Either` type constructor, there is ample documentation of its use.  In this example it provides two constructors, `Left` and `Right` that contain an `ABE` value and a `String` respectively.  We'll use the `Either` type to return either an `ABE` value, `v` (`Left v`) or a string error message, `s` (`Right s`).  We can then use a `case` expression to discriminate between values.  Any time we call `evalError` we can do something like this:

{% highlight haskell %}
case (evalErr t) of
  (Left v) -> actions taken for a value v
  (Right m) -> actions taken for an error message m
{% endhighlight %}

We're going to use this pattern extensively in our new definition of `evalErr`.

Start with the two easy cases for number and Boolean constants.

{% highlight haskell %}
evalErr (Num t) = (Left (Num t))
evalErr (Boolean b) = (Left (Boolean b))
{% endhighlight %}

In `eval`, both numbers and Booleans evaluate to themselves and cannot crash.  Thus, in `evalErr` we don't need to deal with errors.  The return value is `(Left (Num t))`, with `Left` indicating a value and `(Num t)` being the value.

Constant cases are not particularly interesting, so let's look at `isZero`.  Unlike the constant cases, `isZero` can fail when evaluating its argument or when its arguments is not a number:

{% highlight haskell %}
evalErr (IsZero t) =
  let r = (evalErr t)
  in case r of
       (Right m) -> r
       (Left (Num v)) -> (Left (Boolean (v == 0)))
       (Left _) -> (Right "Type error in isZero")
{% endhighlight %}

What's happening here?  First the argument to `IsZero` is evaluated and assigned to `r`.  By definition we know that `r` is now either a value or some error message.  We'll use our pattern from above to decide what we're looking at.

The first option is `(Right m)`.  This occurs when evaluating `t` results in an error.  If this is the case, we have no work to do and we simply return the error message for the calling function to deal with.

The second option is `(Left (Num v))`.  If this pattern matches we know two things.  First, that `evalErr t` returned a value and that value is a `Num`.  This is the success case and we return `(Left (Boolean (v==0)))`.  `Left` because we have a value, `Boolean` to construct a Boolean value, and `v==0` to calculate the Boolean value.

The final option is `(Left _)`.  If this pattern matches we know the previous pattern did not.  Thus, we have a value and that value is not a number.  In this case we create an error message and return it as `(Right "Type error in isZero")`.  `Right` because we have an error and `"Type error in isZero"` as the error value.

To summarize, evaluating `IsZero` requires evaluating its argument and taking one of three actions:

1. Return the result if it is an error
2. Return the comparison of the result with 0 if it is a number
3. Retern an error message if it is a value, but not a number

The remaining binary operations are virtually the same except we have two arguments to evaluate and need to nest handling argument results.  You'll see our pattern occurring twice in the code for `Plus`:

{% highlight haskell %}
evalErr (Plus t1 t2) =
  let r1 = (evalErr t1)
      r2 = (evalErr t2)
  in case r1 of
       (Right m) -> r1
       (Left (Num v1)) -> case r2 of
                            (Right m) -> r2
                            (Left (Num v2)) -> (Left (Num (v1+v2)))
                            (Left _) -> (Right "Type Error in +")
       (Left _) -> (Right "Type Error in +")

{% endhighlight %}

There is no magic here!  We calculate the values of both arguments and store the results in `r1` and `r2` respectively.  Then we apply the same pattern as `IsZero` and determine if the first argument is an error, number, or something else.  In the error and something else cases, we do exactly what we did previously.  In the number case, we repeat the same process for `r2` and do the same thing.  In the error and something else cases, we do exactly what we did previously.  IN the number case, we calculate the result of `Plus` and return it as `(Left (Num (v1+v2)))`.  The other binary operations follow similarly.

The remaining operation is `if` that is treated like a one parameter expression.  The condition is evaluated and the outcome handled using the same pattern as other expressions.  If the condition evaluates to a Boolean, them we choose the expression to evaluate based on the Boolean value.  The final code has the following form:

{% highlight haskell %}
evalErr (If t1 t2 t3) =
  let r = (evalErr t1)
  in case r of
       (Right _) -> r
       (Left (Boolean v)) -> if v then (evalErr t2) else (evalErr t3)
       (Left _) -> (Right "Type error in if")
{% endhighlight %}

Once the interpreter is completed, we can define an interpreter function in a manner similar to the original interpreter function for `eval`:

{% highlight haskell %}
interpErr = evalErr . parseABE
{% endhighlight %}

Now we're set to test our new interpreter

### QuickCheck

The same functions used for testing the original `ABE` evaluator are also useful for `evalErr`.  We simply substitute `interpErr` for `interp` in the test functions:

{% highlight haskell %}
testEvalErr :: Int -> IO ()
testEvalErr n = quickCheckWith stdArgs {maxSuccess=n}
  (\t -> (interpErr $ pprint t) == (evalErr t))
{% endhighlight %}

Running `testEvalErr` for 1000 random cases reveals that we accomplished our original goal of having an evaluator for `ABE` that does not crash.

However, we can do more.  Let's compare `eval` and `evalErr` to assess whether our new implementation agrees with our original implementation.  Unfortunately, this is not as simple as creating a function that compares the results of `eval` and `evalErr` like this:

{% highlight haskell %}
\t -> eval t == evalErr t
{% endhighlight %}

because the return type of `eval` is different than the return type of `evalErr` and `eval` still crashes.  What we care about are cases when `eval` should not crash and produce a value.  We can't test for  `eval` not crashing, but we can test for when `evalErr` produces a value rather than an error.  Remember `Left` and `Right`?  When `evalErr` returns a `Left` value we know it produced a value and `eval` should also produce a value.  When `evalErr` returns a `Right` we know it produced an error message and we should not evaluate `eval`.  Here's a function to do just this:

{% highlight haskell %}
  (\t -> (let r = (evalErr t) in
            case r of
              (Left v) -> v == (eval t)
              (Right v) -> True))
{% endhighlight %}

The `case` performs exactly the check we need.  `Left` compares the value generated with the results of `eval` on `t`.  `Right` just returns  `True`.  Why?  QuickCheck checks to see if the conjunction of all tests succeed.  `True` causes QuickCheck to, in essense, ignore the case.  Exactly what we want.  Here's the QuickCheck function:

{% highlight haskell %}
testEvals :: Int -> IO ()
testEvals n = quickCheckWith stdArgs {maxSuccess=n}
  (\t -> (let r = (evalErr t) in
            case r of
              (Left v) -> v == (eval t)
              (Right v) -> True))
{% endhighlight %}

Running `testEvals` on a thousand test cases should generate no errors.

Where QuickCheck was helpful in earlier tests, it shines here.  We updated `eval` and we want to make sure we did not introduce errors.  This is exactly what QuickCheck's random testing does for us.  Whether developing interpreters or other tools, this technique will prove exceptionally useful.

## Static Error Prediction



## Definitions

- Host Language - The language used to implement tools for another language.
- Domain Specific Language - The new language for which we're building tools.
- Static - Before execution
- Dynamic - During execution

## Exercises

## Source