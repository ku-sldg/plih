---
layout: project
category: project
title: Project 4 - State and Assignment
when: May 16, 2014
---

Project 4 - Assignment and State 
EECS 662 - Programming Languages

The objective of this miniproject is to add assignment, state, and
sequencing the CFWAE language.  You will define an interpreter for
CFWAES, an extension for CFWAE that includes state and
sequencing. Your interpreter will differ from the BCFWAE interpreter
developed  in class in that *every* defined variable - `with` and
`fun` - will have an associated location when it is created. We will
use a single `assign` command to change the value referenced by a
variable. 

## Exercise 1
  
In this exercise you will write a parser and interpreter for a
modified CFWAE language that allows assignment and sequential
execution. The following table defines the grammar for this language
that we will call CFWAES. 

    CFWAES ::= number} | id |
            { + CFWAES CFWAES } |
            { - CFWAES CFWAES } |
            { * CFWAES CFWAES } |
            { / CFWAES CFWAES } |
            { with { id CFWAES } CFWAES } |
            { fun id CFWAES } |
            { CFWAES CFWAES } |
            { if0 CFWAES CFWAES CFWAES } |
            { seq CFWAES CFWAES } |
            { assign id CFWAES }

CFWAES's features include static scoping, first-class functions and
closures, and strict evaluation semantics.  Your interpreter will also
include assignment (the `assign` operation) and sequential execution
(the `seq` operation).

Every element of the CFWAES environment will contain a location.  This
simplifies both the environment and how it is used, but eliminates
some functionality.  Store elements may contain any value including
another location.  As a result, any time the value of a variable is
needed its location is retrieved from the environment and used to
retrieve its value from the store.

1. Define types for representing the abstract syntax, values,
   environment, and store associated the CFWAES language.  Your
   `CFWAES-Value` type must minimally define, but is not limited to
   numbers and closures.  You may or may not need to include other
   values.  Your your environment type must represent pairs of
   identifiers and locations while your store type must represent
   pairs of locations and values.[^1]

1. Write a function, `(parse-cfwaes expr)`, that accepts the concrete
   syntax of CFWAES and generates a CFWAES data structure representing
   it.  If your parser fails, it should throw an error using the
   `error` function discussed in class.

1. Write a function, `(interp-cfwaes expr env sto)`, that takes a
   CFWAES data structure, environment and store.  It should interpret
   the CFWAES data structure, and return a value and store as a pair.
   Using the `Value*Store` structure from your text is an excellent
   way to do this.  If your interpreter fails, it should throw an
   error using the `error` function discussed in class.

1. Write a function, `(eval-cfwaes expr)` that combines your parser
   and interpreter into a single function that parses and then
   interprets a CFWAES expression.  It should return only the
   resulting value, not the value/store pair generated by the
   interpreter.  The interpreter should be called from within
   `eval-cfwaes` with an empty environment and store. Your interpreter
   should not be called if the parser fails.

We have implemented the interpretation of all constructs in CFWAES
except `seq` and `assign`.  You should know how to implement strict
evaluation, `with`, `if0`, and fist-class functions.  However, you
will need to modify your interpreter definitions to handle both an
expression and store as inputs and return the value/store pair.

The `seq` expression is relatively simple to implement.  The
construct:

    { seq expr0 expr1 }

interprets `expr0` followed by `expr1` and returns the result of
interpreting `expr1`.  Note that the store that results from
interpreting `expr0` must be passed to `expr1` as interpreting `expr0`
may change the values of identifiers.  If you don't do this, then the
interpretation of one expression can never have any impact on the
expression following.

The `assign` expression involves calculating a value and storing that
value in a location.  In the term:

    { assign x expr }

`x` must be an identifier while `expr` may be any expression.  `expr`
is interpreted first returning a value and store. Any identifiers
appearing in `expr` are resolved to values by retrieving their
location from the environment and value from the store.  The resulting
valued is stored in the store location associated with `x` in the
environment.  The identifier, `x`, is treated as a location while
identifiers in `expr` are resolved to values.  Specifically, `x` is
not evaluated, but simply looked up in environment to get a location
where the result of evaluating `expr` is stored.  The `assign`
operation can be defined:

    { assign x expr } == { setbox x expr }

using our BCFWAE language from class.

Given how identifiers work, The `with` expression must be updated to
handle allocation of store locations in addition to creating new
entries in the current environment.  In the expression:

    {with { x expr } body }

`x` is an identifier whose value will be determined by `expr` that may
be referenced in `body`.  In previous interpreters, `x` would be added
to the environment associated with the value determined by
interpreting `expr`.  This remains true, except that `x` will refer to
a new location in the store and the value will be stored in that new
location.  When the `with` is evaluated, a new entry must be added to
the store, associated with the identifier, and initialized with the
value found by interpreting `expr`.  The `with` expression from CFWAES
can be defined:

    { with { x } body } == { with { x {newbox expr } } body }

using the `with` expression and `newbox` expressions from our BCFWAE
language in class.

Remember also that evaluating `expr` may change the store.  Thus, the
store that results from interpreting `expr` must be the store used
when interpreting `body`.

An issue that pervades the entire interpreter for CFWAES is the
threading of state.  Even simple expressions such as binary operations
must make sure that updates to the store are propagated. If an
expression involves multiple sub-expressions that may be evaluated,
the store must be passed from one interpretation to the next as
sub-expressions are evaluated.  For example, in:

    { + { f x } { g y } }

interpreting `{ f x }` may update the environment in some way.  If `f`
has the definition:

    { fun x { assign y x } }

then the value of `y` changes during interpretation. This new value
must be propagated to the interpretation of `{ g y }` using the
updated store.

Anytime an expression involves interpretation of multiple
sub-expressions, threading state by updating the store will be an
issue.  We have seen this play out for `with` and `+`, but it will
apply to other expressions as well.  For the purposes of this project,
always assume that sub-expressions are evaluated from left to right.
Thus, the store will propagate right from the leftmost sub-expression
through to the last sub-expression.

## Notes

There is only one exercise in this miniproject.

Pay close attention to the `Value*Store` data type and the pattern
that emerges when using it. The pattern:

    (type-case CFWAES-Value (interp expr env sto)
      (v*s (the-value the-sto)
        <<use the-value and the-sto in the code body>>
        ))

binds `the-value` and `the-sto` to the value and store results from
`interp`.  They can be used like they were defined using a `let` or
`local` and will go away with the context closes.  This is extremely
handy.  See class notes as well as the book in Chapter 13 to see how
it is used.

Think carefully about how function values are handled and how that
changes CFWAES.  They are stored exactly like other values in the
store.  Don't think too hard about this.

Do not think at all about how the store behaves computationally.  It
is inefficient and we know that.  Don't try anything crazy to somehow
make it work more like memory.

This miniproject is loosely based on Shriram Krishnamurthy's homework
assignments associated with *Programming Languages: Application and
Interpretation*.  Any errors in the writeup are exclusively mine.

[^1]:It would be a good idea here to follow the directions indicated in code from the textbook.
