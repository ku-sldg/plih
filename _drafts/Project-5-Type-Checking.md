---
layout: project
categories: project
title: Optional Project 5 - Type Checking
when: December 18
---

Project 5 - Adding Type Checking 
EECS 662 - Programming Languages 

The objective of this project is to add type checking to CFWAE from Project 2.  You will define a type checker for CFWAE and integrate type checking into the CFWAE interpreter.  Specifically, you will parse your CFWAE expression, type check the resulting AST, elaborate to CFAE, and evaluate the result.

## Exercise 1

In this exercise you will write a type checker for the CFWAE language identical to that used in Project 2 with the addition of syntax for types.  First, a type language is defined that provides for number types and function types.  A number type is represented by the keyword `number` while a function type is represented by the syntax:

    { -> *dom* *ran* }

where *dom* is the domain type and *ran* is the range type.  For example, the type `{-> number number }` is the type of a function mapping numbers to number.  The type `{-> number {-> number number}}` is the type of a function mapping a number to a function from one number to another.

Second, a type is added to the parameter specification for a function.  The original function definition syntax that did not include a parameter type:

    { fun id *CFWAE* }

is modified to add a type to the input parameter:

    { fun { id *TY* } *CFWAE* }

For example, the syntax for defining a simple increment function becomes:

    {fun {x number} {+ x 1}}

1. Define a datatype representing the abstract syntax for CFWAE
    including the new syntax for functions and types.  Your new type will be almost identical to the CFWAE type from Project
1. Define a datatype representing types associated with CFWAE
    expressions.  Specifically, your type should resemble the type
    defined in class and represent both number and function
    types. Note that this datatype is not technically necessary, but parallels the type checker developed in class.
 1. Write a function, `(typeof expr)`, that takes a CFWAE data
	structure and returns its type.  If no type can be found, `typeof` should throw an error.  Think of this as an interpreter that produces type values rather than traditional values.

## Notes

Note that the type checker is called after parsing, but before
elaboration.  This should make sense to you if you think about a
compiler - do you want type errors referencing your source code or referencing code generated by the compiler?

You can get quite a bit of your code from class notes or the text.  In class we have defined type checking for all constructs in CFWAE except `cond0`.  You will need to define when a `cond0` construct is correctly typed and implement this check in your type checker.  This is not hard if you think about the reasoning we went through for requiring both arms of `if0` to be the same type.

This miniproject is loosely based on} Shriram Krishnamurthy's homework assignments associated with *Programming Languages: Application and Interpretation*. Any errors in the writeup are exclusively mine.


