---
layout: frontpage
title: Failure
use_math: true
category: chapter
---

$$
\newcommand\calc{\mathsf{calc}\;}
\newcommand\parse{\mathsf{parse}\;}
\newcommand\typeof{\mathsf{typeof}\;}
\newcommand\interp{\mathsf{interp}\;}
\newcommand\eval{\mathsf{eval}\;}
\newcommand\NUM{\mathsf{NUM}\;}
\newcommand\iif{\mathsf{if}\;}
\newcommand\tthen{\;\mathsf{then}\;}
\newcommand\eelse{\;\mathsf{else}\;}
\newcommand\iisZero{\mathsf{isZero}\;}
\newcommand\aand{\;\mathsf{\&\&}\;}
\newcommand\lleq{\;\mathtt{<=}\;}
\newcommand\ttrue{\;\mathsf{true}}
\newcommand\ffalse{\;\mathsf{false}}
$$

# Failure Is an Option

We've established that `ABE` fails for test cases that attempt to use Boolean values where numbers should be used or numbers where Boolean values should be used.  Before addressing that specific problem, let's look at how failure should be handled generally.

First a bit of new terminology.  We are defining a new language called `ABE` using Haskell to build parsers and interpreters.  We will refer to `ABE` as the *external language* or *domain specific language*.  We refer to Haskell as the *host language* or *implementation language*.  The distinction is we are building tools for `ABE` and using Haskell to build them.

When the current `ABE` interpreter fails, it fails in the host language.  When we call the Haskell `error` function we jump out of our interpreter and generate a Haskell error message.  This approach works, but has several problems.

First, we have no control over errors.  The happen and our control of execution ends.  Java uses an innovative approach where exceptions are Java data structures that allow us to write Java programs to process them.  This is how systems like Eclipse can allow new tools that generate error messages to simply be plugged into the infrastructure.  Right now, we can't do this.

Second, our only choice is to fail.  What if our interpreters can avoid failures?  What if we can predict failures during or before execution?  This results in systems that are more robust and code that we can better control.

Let's look at two approaches to handling errors.  The first will handle them *dynamically* or at run-time.  Our interpreter will generate error messages as data structures that we can process how we choose.  The second will handle them *statically* by predicting runtime failure before execution.

## Runtime Error Checking

Let's change the type signature of the `ABE` `eval` function just a bit and define a new function called `evalErr` that returns either a n `ABE` term or a string representing an error:

{% highlight haskell %}
evalErr :: ABE -> Either ABE String
{% endhighlight %}

If you're not familiar with the `Either` type constructor, there is ample documentation of its use.  In this example it provides two constructors, `Left` and `Right` that contain an `ABE` value and a `String` respectively.  We'll use the `Either` type to return either an `ABE` value, `v` (`Left v`) or a string error message, `s` (`Right s`).  We can then use a `case` expression to discriminate between values.  Any time we call `evalError` we can do something like this:

{% highlight haskell %}
case (evalErr t) of
  (Left v) -> actions taken for a value v
  (Right m) -> actions taken for an error message m
{% endhighlight %}

We're going to use this pattern extensively in our new definition of `evalErr`.

Start with the two easy cases for number and Boolean constants.

{% highlight haskell %}
evalErr (Num t) = (Left (Num t))
evalErr (Boolean b) = (Left (Boolean b))
{% endhighlight %}

In `eval`, both numbers and Booleans evaluate to themselves and cannot crash.  Thus, in `evalErr` we don't need to deal with errors.  The return value is `(Left (Num t))`, with `Left` indicating a value and `(Num t)` being the value.

Constant cases are not particularly interesting, so let's look at `isZero`.  Unlike the constant cases, `isZero` can fail when evaluating its argument or when its arguments is not a number:

{% highlight haskell %}
evalErr (IsZero t) =
  let r = (evalErr t)
  in case r of
       (Right m) -> r
       (Left (Num v)) -> (Left (Boolean (v == 0)))
       (Left _) -> (Right "Type error in isZero")
{% endhighlight %}

What's happening here?  First the argument to `IsZero` is evaluated and assigned to `r`.  By definition we know that `r` is now either a value or some error message.  We'll use our pattern from above to decide what we're looking at.

The first option is `(Right m)`.  This occurs when evaluating `t` results in an error.  If this is the case, we have no work to do and we simply return the error message for the calling function to deal with.

The second option is `(Left (Num v))`.  If this pattern matches we know two things.  First, that `evalErr t` returned a value and that value is a `Num`.  This is the success case and we return `(Left (Boolean (v==0)))`.  `Left` because we have a value, `Boolean` to construct a Boolean value, and `v==0` to calculate the Boolean value.

The final option is `(Left _)`.  If this pattern matches we know the previous pattern did not.  Thus, we have a value and that value is not a number.  In this case we create an error message and return it as `(Right "Type error in isZero")`.  `Right` because we have an error and `"Type error in isZero"` as the error value.

To summarize, evaluating `IsZero` requires evaluating its argument and taking one of three actions:

1. Return the result if it is an error
2. Return the comparison of the result with 0 if it is a number
3. Retern an error message if it is a value, but not a number

The remaining binary operations are virtually the same except we have two arguments to evaluate and need to nest handling argument results.  You'll see our pattern occurring twice in the code for `Plus`:

{% highlight haskell %}
evalErr (Plus t1 t2) =
  let r1 = (evalErr t1)
      r2 = (evalErr t2)
  in case r1 of
       (Right m) -> r1
       (Left (Num v1)) -> case r2 of
                            (Right m) -> r2
                            (Left (Num v2)) -> (Left (Num (v1+v2)))
                            (Left _) -> (Right "Type Error in +")
       (Left _) -> (Right "Type Error in +")

{% endhighlight %}

There is no magic here!  We calculate the values of both arguments and store the results in `r1` and `r2` respectively.  Then we apply the same pattern as `IsZero` and determine if the first argument is an error, number, or something else.  In the error and something else cases, we do exactly what we did previously.  In the number case, we repeat the same process for `r2` and do the same thing.  In the error and something else cases, we do exactly what we did previously.  IN the number case, we calculate the result of `Plus` and return it as `(Left (Num (v1+v2)))`.

The other binary operations work similarly by simply changing the calculation and what we test off.

## Static Error Prediction

## Definitions

- Host Language - The language used to implement tools for another language.
- Domain Specific Language - The new language for which we're building tools.
- Static - Before execution
- Dynamic - During execution

## Exercises

## Source